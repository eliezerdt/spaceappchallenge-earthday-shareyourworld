{
  "name": "jsonraver",
  "version": "0.5.0",
  "description": "An easy-to-use Node.js utility module for performing multiple async GET requests to third party JSON web services simultaneously through a simple API with batch-request functionality.",
  "scripts": {
    "test": "mocha"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/deeleman/jsonraver.git"
  },
  "bugs": {
    "url": "https://github.com/deeleman/jsonraver/issues"
  },
  "main": "./lib/main",
  "keywords": [
    "json",
    "request",
    "get",
    "batch",
    "async"
  ],
  "dependencies": {
    "request": "2.11.x"
  },
  "devDependencies": {
    "mocha": "1.6.x",
    "express": "3.0.x"
  },
  "author": {
    "name": "Pablo Deeleman",
    "email": "deeleman@gmail.com"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "https://github.com/deeleman/jsonraver/raw/master/LICENSE"
    }
  ],
  "readme": "JSON Raver [![endorse](http://api.coderwall.com/deeleman/endorsecount.png)](http://coderwall.com/deeleman) \r\n=========\r\n\r\nAn easy-to-use Node.js utility module for performing one or multiple async GET requests to third party JSON web services simultaneously though a simple API with batch-request functionality.\r\n\r\n[![Build Status](https://secure.travis-ci.org/deeleman/jsonraver.png)](http://travis-ci.org/deeleman/jsonraver)\r\n\r\n----------\r\n\r\n# Why JSON Raver? #\r\n\r\nNode.js is cool when it comes to consuming web services thanks to its awesome architecture and the impressive module ecosystem around it, featuring excellent tools such as [HTTP](http://nodejs.org/api/http.html \"HTTP\") or [Request](https://github.com/mikeal/request) (JSON Raver leverages the latter to perform all GET requests - Thanks [Mikeal](https://github.com/mikeal)!). But whoever has felt in the need to consume more than one service at once and therefore build a composite JSON message with all the information returned knows that avoiding the infamous [callback hell](http://callbackhell.com/) is a pain in the ass. \r\n\r\n**This is why JSON Raver was created.** The idea behind this NodeJS module is quite simple: To provide the simplest interface to make asyncrononous requests to different web services exposing JSON data and return a composite JSON message with all the information gathered once all http requests have been accomplished and HTTP exceptions have been handled.\r\n\r\n**JSON Raver is for you if...**\r\n\r\n- You want to consume several web services at once and render a web page with all the information gathered in a single object.\r\n- You need to fetch data from different JSON sources and provide graceful fallbacks when one or some of those sources fail returning data.\r\n- You prefer to turn asyncronous consumption of spare web services into a single asyncronous action.\r\n\r\n**JSON Raver is *NOT* for you if...**\r\n\r\n- You need to pass data in your request by POST.\r\n- You need to execute POST, PUT or DELETE http actions. \r\n- You need to consume data served in a format other than JSON.\r\n- You want to execute a *fire & forget* GET request. JSON Raver will require a callback to be defined in its payload (regardless the callback provided in the payload is populated or not)\r\n\r\n## Installation ##\r\n\r\nVia [npm](http://github.com/isaacs/npm):\r\n\r\n```javascript\r\nnpm install jsonraver\r\n```\r\n\r\n**Note:** JSON Raver requires [mocha](https://github.com/visionmedia/mocha) to run the unit tests, but you won't need it for just using the module.\r\n\r\n----------\r\n# How to Use JSON Raver#\r\n\r\nFor all our examples we will figure out that we need to consume 2 separate REST services that provide GEO data in JSON format: One returns GEO coordinates and the other one exposes demographic info.\r\n\r\n## Performing single JSON GET requests ##\r\n\r\nLet's figure out you want to consume the coordinates of London from our example GEO data service.\r\n\r\n```javascript\r\nvar jsonraver = require('jsonraver'), geodata;\r\n\r\njsonraver('http://www.example.com/geo/coords/london.json', function(err, data) {\r\n\tif(err) {\r\n\t\t// Error is handled - Read below for details about error handling\r\n\t} else {\r\n\t\tgeodata = data;\r\n\t}               \r\n});\r\n```\r\n\r\nThe `geodata` variable would be populated with the following fixture content. The leading parent \"0\" node refers to the index corresponding to the data requested. It is customisable and quite useful for applying structure to batch requests entailing several calls to different JSON web services:\r\n\r\n```javascript\r\n{\r\n\t'0' : {\r\n\t\tlatitude: 51.506944,\r\n\t\tlongitude: -0.1275\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## Performing composite JSON GET requests ##\r\n\r\nNow we are going to push our example one step forward by requesting the two GEO data services mentioned above. For doing so, we include an array of URIs instead of a plain string.\r\n\r\n```javascript\r\nvar webServices = [\r\n\t'http://www.example.com/geo/coords/london.json', \r\n\t'http://www.example.com/geo/demographics/london.json'\r\n];\r\n\r\njsonraver(webServices, function(err, data) {\r\n\t// Error handling removed for brevity's sake\r\n\tgeodata = data;         \r\n});\r\n```\r\n\r\nThe resulting output would populate the `geodata` variable with this information. Again, pay attention to how each block of data corresponding to each call has an index parent node:\r\n\r\n```javascript\r\n{\r\n\t'0' : {\r\n\t\tlatitude: 51.506944,\r\n\t\tlongitude: -0.1275\r\n\t},\r\n\t'1' : {\r\n\t\tpopulation: 7556900,\r\n\t\tdensity: 4761,\r\n\t\tdemonym: 'londoner'\r\n\t}\r\n}\r\n```\r\n\r\n## Customising output ##\r\n\r\nAll blocks will keep the same sorting order in which the requests were made inside the request array to ease coupling afterwards each request with its corresponding index parent node. In any event, you will be willing to get a more elegant returning message. No worries! JSON Raver allows you to customise the name of each parent name according to your requirements. Just see how we can turn each call into an object literal and assign an `id` member to each call that will turn into the parent node of the corresponding return data block:\r\n\r\n```javascript\r\nvar webServices = [\r\n\t{ id: 'coords', uri: 'http://www.example.com/geo/coords/london.json' },\r\n\t{ id: 'population', uri: 'http://www.example.com/geo/demographics/london.json' }\r\n];\r\n\r\njsonraver(webServices, function(err, data) {\r\n\t// Error handling removed for brevity's sake\r\n\tgeodata = data;         \r\n});\r\n```\r\n\r\nThis call would return the following object, making it easier to address each data block regardless the order they were pulled into the request array:\r\n\r\n```javascript\r\n{\r\n\t'coords' : {\r\n\t\tlatitude: 51.506944,\r\n\t\tlongitude: -0.1275\r\n\t},\r\n\t'population' : {\r\n\t\tpopulation: 7556900,\r\n\t\tdensity: 4761,\r\n\t\tdemonym: 'londoner'\r\n\t}\r\n}\r\n```\r\n\r\n## Adding per-request callbacks ##\r\n\r\nOnce each and every request has been accomplished (succesfully or not, see \"handling errors\" below) and the composite object has been built and returned throughb the callback function, we may consider that the job is done. But, what if we need to take decisions when an specific request in our batch is accomplished?\r\n\r\nA good example of this would be when we need to provide graceful fallbacks in case one or some of the requests fail, or when we need to perform operations with any of the returning data as soon as it is available. Following the example above, let's add an onComplete callback to the first call or our payload:\r\n\r\n```javascript\r\nvar webServices = [\r\n\t{ \r\n\t\tid: 'coords', \r\n\t\turi: 'http://www.example.com/geo/coords/london.json', \r\n\t\tonComplete: function(err, data) { \r\n\t\t    // We manage both the error and data handling inside this callback\r\n\t\t} \r\n\t},\r\n\t{ \r\n\t\tid: 'population', \r\n\t\turi: 'http://www.example.com/geo/demographics/london.json' \r\n\t}\r\n];\r\n```\r\n\r\nWe should remark that the returning object in the per-request callback does not include any index parent node regardless we include any when defining the request object. This may change at any point and any feedback would be appreciated.\r\n\r\n## Handling errors ##\r\n\r\nThis is not a perfect world, shit happens and errors occur. JSON Raver provides functionality to debug easily your app and keep everything working smoothly by allowing the developer to handle all exceptions on a per-request basis or once all the request have been accomplished.\r\n\r\n### Anatomy of errors on a per request basis ###\r\n\r\nIf we define an `onComplete` callback on any of our requests, the returning error will feature the following format:\r\n\r\n```javascript\r\n{\r\n\thttpStatus: [HTTP integer status returned by the remote JSON web service if any],\r\n\tmessage: '[Detailed error message here]'\r\n}\r\n\r\n```\r\n\r\n### Anatomy of errors returned in the global callback ###\r\n\r\nThe format is pretty much the same weÂ´ve just seen above with only one remarkable difference: The callback returns an array of error objects (one per each failed request) instead of a single object and each error object contains a `requestId` property so we can easily match each error with its corresponding request. Let's perform a composite call with a wrong URI:\r\n\r\n```javascript\r\nvar webServices = [\r\n\t{ \r\n\t\tid: 'coords', \r\n\t\turi: 'http://www.example.com/geo/coords/london.json', \r\n\t\tonComplete: function(err, data) { \r\n\t\t\t// We manage both the error and data handling inside this callback\r\n\t\t} \r\n\t},\r\n\t{ \r\n\t\tid: 'population', \r\n\t\turi: 'http://www.bad-domain.com/returns/nothing' \r\n\t}\r\n];\r\n```\r\n\r\nWould return the following error through the global callback:\r\n\r\n\r\n```javascript\r\n[{\r\n\thttpStatus: 204, \r\n\tmessage: 'http://www.bad-domain.com/returns/nothing returned NO CONTENT' ,\r\n\trequestId : 'population'\r\n}]\r\n\r\n```\r\n\r\n----------\r\n# License - \"BSD License\" #\r\n\r\nCopyright (c) 2012, Pablo Deeleman\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\r\n\r\n- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\r\n- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n\r\n\r\n\r\n\r\n",
  "_id": "jsonraver@0.5.0",
  "dist": {
    "shasum": "527dffc5825263a3f57978084f45a41567a5526b"
  },
  "_from": "jsonraver"
}
